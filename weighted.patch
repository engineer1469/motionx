diff --git a/src/motionx/core.py b/src/motionx/core.py
--- a/src/motionx/core.py
+++ b/src/motionx/core.py
@@
+import collections

@@
 class Mog2Params:
@@
     detect_shadows: bool = True
+
+@dataclass
+class WeightedParams:
+    """
+    Parameters for the weighted motion extraction algorithm.
+
+    ``alpha`` and ``beta`` are the blending weights for the current frame and the
+    inverted previous frame, respectively.  ``offset`` specifies how many
+    frames to delay before computing the difference; a value of 1 means the
+    immediate previous frame.
+    """
+    alpha: float = 0.5
+    beta: float = 0.5
+    offset: int = 1

@@ class MotionExtractor:
-        if method not in {"diff", "mog2"}:
-            raise ValueError("method must be 'diff' or 'mog2'")
-        self.method = method
+        if method not in {"diff", "mog2", "weighted"}:
+            raise ValueError("method must be 'diff', 'mog2' or 'weighted'")
+        self.method = method

@@ class MotionExtractor:
         self.diff_params = diff_params or DiffParams()
         self.mog2_params = mog2_params or Mog2Params()
-        self._prev_gray: Optional[np.ndarray] = None
-        self._mog2 = None
-        if self.method == "mog2":
-            self._mog2 = cv2.createBackgroundSubtractorMOG2(
-                history=self.mog2_params.history,
-                varThreshold=self.mog2_params.var_threshold,
-                detectShadows=self.mog2_params.detect_shadows,
-            )
+        self.weighted_params = weighted_params or WeightedParams()
+        self._prev_gray: Optional[np.ndarray] = None
+        self._frame_buffer: Optional[collections.deque] = None
+        self._mog2 = None
+        if self.method == "mog2":
+            self._mog2 = cv2.createBackgroundSubtractorMOG2(
+                history=self.mog2_params.history,
+                varThreshold=self.mog2_params.var_threshold,
+                detectShadows=self.mog2_params.detect_shadows,
+            )
+        elif self.method == "weighted":
+            # initialise a ring buffer for the weighted method
+            self._frame_buffer = collections.deque(maxlen=self.weighted_params.offset)

@@ class MotionExtractor:
     def reset(self) -> None:
         self._prev_gray = None
+        # reset weighted buffer if necessary
+        if self.method == "weighted":
+            self._frame_buffer = collections.deque(maxlen=self.weighted_params.offset)

@@ class MotionExtractor:
-        Returns a uint8 mask (0/255) of motion regions for the given frame.
+        Returns a motion representation for the given frame.  For the 'diff' and
+        'mog2' methods this will be a binary mask (0/255).  For the 'weighted'
+        method this will be a full colour image where static pixels are neutral
+        grey and motion is highlighted.

@@ def process(self, frame_bgr: np.ndarray) -> np.ndarray:
-        else:  # mog2
-            assert self._mog2 is not None
-            fgmask = self._mog2.apply(frame_bgr)  # shadows ~ 127 if detectShadows=True
-            # binarize to 0/255 (ignore shadows)
-            _, mask = cv2.threshold(fgmask, 200, 255, cv2.THRESH_BINARY)
-            return mask
+        elif self.method == "weighted":
+            # ensure buffer exists
+            assert self._frame_buffer is not None
+            # if buffer not filled yet, append and return neutral grey image
+            if len(self._frame_buffer) < self.weighted_params.offset:
+                self._frame_buffer.append(frame_bgr.copy())
+                return np.full_like(frame_bgr, 127, dtype=np.uint8)
+            # pick the oldest frame in the buffer
+            prev_frame = self._frame_buffer[0]
+            # compute weighted blend of current frame and inverted previous frame
+            motion_frame = cv2.addWeighted(
+                frame_bgr,
+                self.weighted_params.alpha,
+                cv2.bitwise_not(prev_frame),
+                self.weighted_params.beta,
+                0,
+            )
+            # update buffer
+            self._frame_buffer.append(frame_bgr.copy())
+            return motion_frame
+        else:  # mog2
+            assert self._mog2 is not None
+            fgmask = self._mog2.apply(frame_bgr)  # shadows ~ 127 if detectShadows=True
+            # binarize to 0/255 (ignore shadows)
+            _, mask = cv2.threshold(fgmask, 200, 255, cv2.THRESH_BINARY)
+            return mask

diff --git a/src/motionx/__init__.py b/src/motionx/__init__.py
--- a/src/motionx/__init__.py
+++ b/src/motionx/__init__.py
@@
-from .core import MotionExtractor, DiffParams, Mog2Params
+from .core import MotionExtractor, DiffParams, Mog2Params, WeightedParams
@@
-__all__ = ["MotionExtractor", "DiffParams", "Mog2Params"]
+__all__ = ["MotionExtractor", "DiffParams", "Mog2Params", "WeightedParams"]

diff --git a/src/motionx/cli.py b/src/motionx/cli.py
--- a/src/motionx/cli.py
+++ b/src/motionx/cli.py
@@
-    p.add_argument("--method", choices=["diff", "mog2"], default="diff")
+    p.add_argument("--method", choices=["diff", "mog2", "weighted"], default="diff")
@@
     p.add_argument("--no-shadows", action="store_true")
+
+    # Weighted params
+    p.add_argument("--alpha", type=float, default=0.5,
+                   help="Blending weight for the current frame (weighted)")
+    p.add_argument("--beta", type=float, default 0.5,
+                   help="Blending weight for the inverted previous frame (weighted)")
+    p.add_argument("--offset", type=int, default=1,
+                   help="Frame offset for weighted motion")
@@
-    extractor = MotionExtractor(method=args.method, diff_params=diff_params, mog2_params=mog2_params)
+    from .core import WeightedParams
+    weighted_params = WeightedParams(alpha=args.alpha, beta=args.beta, offset=args.offset)
+    extractor = MotionExtractor(method=args.method,
+                                diff_params=diff_params,
+                                mog2_params=mog2_params,
+                                weighted_params=weighted_params)
@@
-    sink = FrameSink(
-        output=args.output,
-        frame_size=(info.width, info.height),
-        fps=out_fps,
-        out_seq=args.out_seq,
-        out_dir=args.out_dir,
-    )
+    # determine whether the output should be color
+    is_color = (args.method == "weighted")
+    sink = FrameSink(
+        output=args.output,
+        frame_size=(info.width, info.height),
+        fps=out_fps,
+        out_seq=args.out_seq,
+        out_dir=args.out_dir,
+        is_color=is_color,
+    )

diff --git a/src/motionx/io.py b/src/motionx/io.py
--- a/src/motionx/io.py
+++ b/src/motionx/io.py
@@
-class FrameSink:
-    """
-    Unified writer:
-      - video file (mp4/avi) via VideoWriter
-      - image sequence via template: "out/frame_%06d.png"
-      - image directory via out_dir + auto "frame_%06d.png"
-    """
-    def __init__(
-        self,
-        output: Optional[str],
-        frame_size: Tuple[int, int],
-        fps: float,
-        out_seq: Optional[str] = None,
-        out_dir: Optional[str] = None,
-    ):
+class FrameSink:
+    """
+    Unified writer:
+      - video file (mp4/avi) via VideoWriter
+      - image sequence via template: "out/frame_%06d.png"
+      - image directory via out_dir + auto "frame_%06d.png"
+    """
+    def __init__(
+        self,
+        output: Optional[str],
+        frame_size: Tuple[int, int],
+        fps: float,
+        out_seq: Optional[str] = None,
+        out_dir: Optional[str] = None,
+        is_color: bool = False,
+    ):
@@
-        self._writer: Optional[cv2.VideoWriter] = None
-        self._template: Optional[str] = None
-        self._counter = 0
+        self._writer: Optional[cv2.VideoWriter] = None
+        self._template: Optional[str] = None
+        self._counter = 0
+        self._is_color = is_color
@@
-        elif output and _is_video_file(output):
-            fourcc = cv2.VideoWriter_fourcc(*("mp4v" if output.lower().endswith(".mp4") else "XVID"))
-            self._writer = cv2.VideoWriter(output, fourcc, fps, (w, h), isColor=False)
+        elif output and _is_video_file(output):
+            fourcc = cv2.VideoWriter_fourcc(*("mp4v" if output.lower().endswith(".mp4") else "XVID"))
+            self._writer = cv2.VideoWriter(output, fourcc, fps, (w, h), isColor=is_color)
@@
-    def write(self, frame_gray_or_mask: np.ndarray) -> None:
-        if self._writer is not None:
-            self._writer.write(frame_gray_or_mask)
+    def write(self, frame_gray_or_mask: np.ndarray) -> None:
+        if self._writer is not None:
+            frame = frame_gray_or_mask
+            # handle color/grayscale conversion
+            if self._is_color:
+                # if input is grayscale, convert to BGR
+                if frame.ndim == 2:
+                    frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
+            else:
+                # expect grayscale; if input is color, convert to gray
+                if frame.ndim == 3:
+                    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
+            self._writer.write(frame)
         elif self._template:
             fname = self._template % self._counter
             self._counter += 1
             cv2.imwrite(fname, frame_gray_or_mask)
         else:
             raise RuntimeError("FrameSink not initialized")
